// Use a modified `lunr.Builder.add` which accepts run-length-encoded
// text, so that we can pack our JSON a bit tighter.
lunr.Builder.prototype.addEncoded = function (ref, fieldName, field) {
  var docRef = ref,
    fields = Object.keys(this._fields)

  var tokens = this.tokenizer(field, {
    fields: [fieldName]
  }),
    terms = this.pipeline.run(tokens),
    fieldRef = new lunr.FieldRef(docRef, fieldName),
    fieldTerms = Object.create(null)

  this.fieldTermFrequencies[fieldRef] = fieldTerms
  this.fieldLengths[fieldRef] = 0

  // store the length of this field for this document
  this.fieldLengths[fieldRef] += terms.length

  // calculate term frequencies for this field
  for (var j = 0; j < terms.length; j++) {
    var term = terms[j]
    var count = Number.parseInt(term.str.slice(0, 2));
    term = term.str.slice(2);

    fieldTerms[term] = count

    // add to inverted index
    // create an initial posting if one doesn't exist
    if (this.invertedIndex[term] == undefined) {
      var posting = Object.create(null)
      posting["_index"] = this.termIndex
      this.termIndex += 1

      for (var k = 0; k < fields.length; k++) {
        posting[fields[k]] = Object.create(null)
      }

      this.invertedIndex[term] = posting
    }

    // add an entry for this term/fieldName/docRef to the invertedIndex
    if (this.invertedIndex[term][fieldName][docRef] == undefined) {
      this.invertedIndex[term][fieldName][docRef] = Object.create(null)
    }

    // store all whitelisted metadata about this token in the
    // inverted index
    for (var l = 0; l < this.metadataWhitelist.length; l++) {
      var metadataKey = this.metadataWhitelist[l],
        metadata = term.metadata[metadataKey]

      if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
        this.invertedIndex[term][fieldName][docRef][metadataKey] = []
      }

      this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
    }
  }
}

$(async function () {
  const searchResultIcons = {{ site.search.resultIcons | dump | safe}};
  const searchResultDefaultIcon = '{{site.search.resultDefaultIcon}}';

  const store = await (await fetch('/search.json')).json();
  const idx = lunr(function () {
    this.ref('id');
    this.field('title', { boost: 50 });
    this.field('keywords', { boost: 1 });
    this.field('tags', { boost: 20 });
    this.pipeline.remove(lunr.trimmer);
    this.pipeline.remove(lunr.stopWordFilter);
    this.pipeline.remove(lunr.stemmer);
    for (const i in store) {
      this.add({
        id: i,
        title: store[i].title,
        tags: store[i].tags,
      });
      this.addEncoded(i, 'keywords', store[i].keywords)
    }
  });

  const resultdiv = $('#search-results-list');
  const searchBox = $('input#search-box');

  function getItemParams(idx) {
    const item = store[idx];
    switch (item.type) {
      case "tag":
        return {
          icon: "tag",
          head: `<a class="tag" href="${item.url}">${item.title}</a>`,
          desc: item.excerpt,
        };
      case "post":
        const tags = item.tags;
        const head = `<a href="${item.url}">${item.title}</a>
                  <a class="tag ms-2" href="/tags/${tags[0]}/">${tags[0]}</a>`;
        const desc = item.excerpt;

        for (const { tag, icon } of searchResultIcons) {
          if (tags.includes(tag))
            return { icon, head, desc };
        }

        return { icon: searchResultDefaultIcon, head, desc };
    }
  }

  function addResults(result) {
    resultdiv.empty();
    resultdiv.prepend(`<p class="search-results-list__count ps-1">${result.length} result(s) found</p>`);

    for (const item in result) {
      const idx = result[item].ref;
      const { icon, head, desc } = getItemParams(idx);

      const child = $(`
      <div class="d-flex flex-row align-items-center p-2 border-bottom search-results-list__item">
          <i class="fas fa-${icon} fs-5"></i>
          <div class="d-flex flex-column ms-3">
              <h6 class="d-flex align-items-center mb-0">${head}</h6>
              <span>${desc}</span>
          </div>
      </div>
      `);
      child.appendTo(resultdiv);
    }
  }

  searchBox.on('keyup', function () {
    const query = $(this).val().toLowerCase();

    // if (!query.trim())
    //   return; // Ignore empty input.

    const result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(term => {
          if (!term.trim())
            return;

          q.term(term, { boost: 1 }); // With stemmer, resolve to similar word.

          if (query[query.length - 1] != ' ') {
            // Handle continuing words.
            q.term(term, { usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 });
          }

          // Handle possible typos or near words.
          let d = (term.length >= 8 ? 2 : term.length >= 5 ? 1 : 0);
          q.term(term, { usePipeline: false, editDistance: d, boost: 1 });
        })
      });

    addResults(result);
  });

  $('.modal').on('shown.bs.modal', function () {
    $(this).find('[autofocus]').trigger("focus");
    searchBox.trigger("keyup");
  });
});
