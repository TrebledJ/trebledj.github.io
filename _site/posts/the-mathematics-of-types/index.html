<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>The Mathematics of Types - TrebledJ's Pages</title><meta name="description" content="Programming isn't about mindlessly typing away on a keyboard. There is an aesthetic quality that comes with approaching a problem."><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="trebledj,the mathematics of types,programming isn't about mindlessly typing away on a keyboard. there is an aesthetic quality that comes with approaching a problem.,programming,mathematics,haskell,types,functional,software-engineering,programming-languages"><meta name="robots" content="index,follow"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'sha256-Wv9Tjjg7Y7X5sBbP5AXqAQJA6+eewSRUjoPhNczfpnM=' 'sha256-FBtdNYnNdsvTKcrNIznI+jwGwhW3pNA5x/yQUw8jOPA=' 'sha256-puGfk8by7YflxyCkfgS+RgzE70yM3jYq5c5IrWTe0hM=' 'sha256-qlkNkQyGC5u9Brt4wwVi0MsPO/hVdrz3rzXuWYIkAbM=' 'sha256-fpqHX3vj/TpB8DyMxAUbt+Rpk0g/8oR6BkJd6JriNoo=' 'sha256-J+ryCgKrW+QOH4xdCyPd6R5W3u9wJkXayR7KvtlnCnQ=' 'sha256-kQnTuA4pPVYgo0bCEGXSCEkD+CzMbRrhb5Cn58IydSA=' 'sha256-Deekn20h+++EarpL0nFQLX7JSJv7s/2W9f988ZFAh14=' 'unsafe-hashes' comments.trebledj.me code.jquery.com cdn.jsdelivr.net gist.github.com static.cloudflareinsights.com; style-src 'self' 'unsafe-inline' comments.trebledj.me cdn.jsdelivr.net cdnjs.cloudflare.com github.githubassets.com; font-src 'self' data: comments.trebledj.me cdn.jsdelivr.net cdnjs.cloudflare.com; img-src 'self' data: comments.trebledj.me; frame-src 'self' *.soundcloud.com; connect-src 'self' comments.trebledj.me wss://comments.trebledj.me cloudflareinsights.com formcarry.com;"><link href="/feeds/posts.xml" rel="alternate" title="RSS Feed for TrebledJ's Pages" type="application/rss+xml"><meta property="og:site_name" content="TrebledJ's Pages"><meta property="og:type" content="article"><meta property="og:title" content="The Mathematics of Types - TrebledJ's Pages"><meta property="twitter:title" content="The Mathematics of Types - TrebledJ's Pages"><meta property="og:description" content="Programming isn't about mindlessly typing away on a keyboard. There is an aesthetic quality that comes with approaching a problem.

Algebraic data types (ADTs) encompass a wide range of types commonly used in our day-to-day tasks. Over the past years, they’ve grown in popularity with the rise of modern languages..."><meta property="twitter:description" content="Programming isn't about mindlessly typing away on a keyboard. There is an aesthetic quality that comes with approaching a problem.

Algebraic data types (ADTs) encompass a wide range of types commonly used in our day-to-day tasks. Over the past years, they’ve grown in popularity with the rise of modern languages..."><meta property="og:url" content="https://trebledj.me/posts/the-mathematics-of-types/"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" content="https://trebledj.me/img/posts/programming/concepts/mathematics-of-types/assets/thumbnail-512w.webp"><meta property="twitter:image" content="https://trebledj.me/img/posts/programming/concepts/mathematics-of-types/assets/thumbnail-512w.webp"><meta property="article:published_time" content="2023-04-24T00:00:00.000Z"><meta property="article:author" content="TrebledJ"><meta property="article:section" content="programming"><meta property="article:tag" content="programming"><meta property="article:tag" content="mathematics"><meta property="article:tag" content="haskell"><meta property="article:tag" content="types"><meta property="article:tag" content="functional"><meta property="article:tag" content="software-engineering"><meta property="article:tag" content="programming-languages"><script type="application/ld+json">{"@context": "https://schema.org","@type": "WebSite","name": "TrebledJ's Pages","url": "https://trebledj.me"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/cb/css/icons-3b2a868570ec062c.css"><link rel="stylesheet" href="/cb/x2ljFSZBUH.css" media="print"><script>document.querySelectorAll('link[media|="print"]').forEach(e=>{e.addEventListener("load",()=>e.media="all"),e.sheet&&(e.media="all")})</script><script>const defaultTheme="dark";let icon=void 0;function modeInit(){var e=localStorage.getItem("theme");setMode("dark"===e?"dark":"light"===e?"light":defaultTheme)}function modeInitIcon(){icon=document.getElementById("mode-switch-icon"),isLightTheme()&&(icon.classList.remove("fa-moon"),icon.classList.add("fa-sun"),icon.classList.add("mode-switch-transform"))}function isLightTheme(){return"light"===localStorage.getItem("theme")}function modeSwitcher(){var e=localStorage.getItem("theme");setMode("dark"===e?"light":"light"===e?"dark":defaultTheme)}function setMode(e){"dark"===e?(document.documentElement.setAttribute("data-theme","dark"),localStorage.setItem("theme","dark")):"light"===e&&(document.documentElement.setAttribute("data-theme","light"),localStorage.setItem("theme","light")),icon&&(icon.classList.toggle("fa-moon"),icon.classList.toggle("fa-sun"),icon.classList.toggle("mode-switch-transform"))}modeInit(),document.addEventListener("DOMContentLoaded",()=>{document.getElementById("mode-switch").addEventListener("click",()=>{modeSwitcher()})})</script><script defer src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"><link rel="stylesheet" href="/css/comments.css"><link rel="icon" href="/favicon.ico" type="image/x-icon"></head><body><header><nav class="navbar navbar-expand-md py-2"><div class="container-fluid justify-content-between align-items-center"><button aria-controls="navbar-container" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler shadow-none" data-bs-target="#navbar-container" data-bs-toggle="collapse" type="button"><span id="navbar-toggler-icon"><i class="fas fa-bars"></i></span></button> <a class="navbar-brand no-decoration" href="/">TrebledJ's Pages</a><div class="navbar-collapse collapse" id="navbar-container"><ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about">About</a></li><li class="nav-item"><a class="nav-link" href="/posts">Posts</a></li><li class="nav-item"><a class="nav-link" href="/vulnerability-research">CVEs</a></li><li class="nav-item"><a class="nav-link" href="/music">Music</a></li><li class="nav-item"><a class="nav-link" href="/webroll">Webroll</a></li></ul><ul class="navbar-nav"><li><a class="nav-link me-2" data-bs-toggle="modal" data-bs-target="#search-modal" aria-label="Search..." role="button"><i class="fas fa-search nav-icon"></i></a></li><li><a class="nav-link" id="mode-switch" aria-label="Theme Switch" role="button"><i id="mode-switch-icon" class="fas fa-moon nav-icon"></i></a><script>modeInitIcon()</script></li></ul></div></div></nav><div id="scroll-progress-bar"></div></header><div id="top-of-the-morning-to-you"></div><div id="search-modal" class="modal fade wide-modal" aria-hidden="true" aria-label="Search" tabindex="-1"><div class="modal-dialog"><div class="modal-content"><div class="modal-header pb-2 d-flex flex-row justify-content-between"><div class="container-fluid ps-0" id="search-box-container"><input type="text" autofocus class="container-fluid" id="search-box" placeholder="Search"> <i class="fas fa-search"></i></div><button aria-label="Close" class="btn-close" data-bs-dismiss="modal" type="button"></button></div><div class="modal-body" id="search-results-list"></div></div></div></div><button id="btn-back-to-top" class="btn btn-lg" type="button" aria-label="Back to Top"><i class="fas fa-arrow-up"></i></button><div id="btn-mobile-toc" class="dropup"><button type="button" class="btn btn-lg" data-bs-toggle="dropdown" aria-label="Content"><i class="fas fa-list-ul"></i></button><ul class="dropdown-menu toc-container"><li><nav class="toc"><ol><li><a href="#motivation-for-adts">Motivation for ADTs</a><ol><li><a href="#product-types">Product Types</a></li><li><a href="#sum-types">Sum Types</a></li></ol></li><li><a href="#types-in-the-wild">Types in the Wild</a><ol><li><a href="#product-types-in-the-wild">Product Types in the Wild</a></li><li><a href="#sum-types-in-the-wild">Sum Types in the Wild</a></li></ol></li><li><a href="#the-algebra-of-types">The Algebra of Types</a><ol><li><a href="#types-as-sets">Types as Sets</a></li><li><a href="#isomorphism-of-types">Isomorphism of Types</a></li><li><a href="#unit-values-in-the-algebra-of-types">Unit Values in the Algebra of Types</a></li><li><a href="#enums-as-sum-types">Enums as Sum Types</a></li></ol></li><li><a href="#conclusion-and-recap">Conclusion and Recap</a><ol><li><a href="#references-further-reading">References/Further Reading</a></li></ol></li></ol></nav></li></ul></div><div class="main-container"><div class="page-container col-lg-12"><div class="container-lg px-0"><article class="jw-100 post-article" itemscope itemtype="http://schema.org/BlogPosting"><div class="row flex-row-reverse gx-lg-5"><div class="col-lg-4 d-none d-lg-block"><div class="dim-deep"><div class="metadata-container d-flex"><div class="d-flex flex-row align-items-center"><span><i class="fas fa-calendar post-meta-icon me-1"></i> </span><span class="fs-7 post-posted-date">Posted on <span itemprop="datePublished" content="2023-04-24T08:00:00.000+08:00">2023‑04‑24</span></span></div><div class="d-flex flex-row align-items-center"><span class="post-updated-date-icon"><i class="fas fa-calendar post-meta-icon me-1"></i> </span><span class="fs-7 post-updated-date">Updated on <span itemprop="dateModified" content="2023-09-13T18:29:18.000+08:00">2023‑09‑13</span></span></div><div class="d-flex flex-row align-items-center"><span><i class="far fa-clock post-meta-icon me-1"></i> </span><span class="fs-7">8 minute read</span></div></div><div class="metadata-tag-container"><span><i class="fas fa-tag post-meta-icon me-1 mt-2"></i></span><div class="tag-list d-flex flex-row flex-wrap align-items-center"><span><a class="jtag" href="/tags/programming/" itemprop="keywords">programming</a> </span><span><a class="jtag" href="/tags/mathematics/" itemprop="keywords">mathematics</a> </span><span><a class="jtag" href="/tags/haskell/" itemprop="keywords">haskell</a> </span><span><a class="jtag" href="/tags/types/" itemprop="keywords">types</a> </span><span><a class="jtag" href="/tags/functional/" itemprop="keywords">functional</a> </span><span><a class="jtag" href="/tags/software-engineering/" itemprop="keywords">software-engineering</a> </span><span><a class="jtag" href="/tags/programming-languages/" itemprop="keywords">programming-languages</a></span></div></div></div><br><div id="toc-sidebar" class="sticky-right dim-deep dim-if-dark"><div class="toc-container"><span><a id="toc-content" href="javascript:void(0);">Content</a></span><nav class="toc"><ol><li><a href="#motivation-for-adts">Motivation for ADTs</a><ol><li><a href="#product-types">Product Types</a></li><li><a href="#sum-types">Sum Types</a></li></ol></li><li><a href="#types-in-the-wild">Types in the Wild</a><ol><li><a href="#product-types-in-the-wild">Product Types in the Wild</a></li><li><a href="#sum-types-in-the-wild">Sum Types in the Wild</a></li></ol></li><li><a href="#the-algebra-of-types">The Algebra of Types</a><ol><li><a href="#types-as-sets">Types as Sets</a></li><li><a href="#isomorphism-of-types">Isomorphism of Types</a></li><li><a href="#unit-values-in-the-algebra-of-types">Unit Values in the Algebra of Types</a></li><li><a href="#enums-as-sum-types">Enums as Sum Types</a></li></ol></li><li><a href="#conclusion-and-recap">Conclusion and Recap</a><ol><li><a href="#references-further-reading">References/Further Reading</a></li></ol></li></ol></nav><hr></div><div class="toc-link-container"><span><a href="#related">Related Posts</a></span></div><div class="toc-link-container"><span><a href="#comments">Comments</a></span></div></div></div><div class="col-lg-8 post-body-container"><div class="article-header"><h1 class="post-title" itemprop="name headline">The Mathematics of Types</h1><p class="post-desc" itemprop="alternativeHeadline">Programming isn't about mindlessly typing away on a keyboard. There is an aesthetic quality that comes with approaching a problem.</p><div class="d-lg-none dim-deep"><div class="metadata-container d-flex"><div class="d-flex flex-row align-items-center"><span><i class="fas fa-calendar post-meta-icon me-1"></i> </span><span class="fs-7 post-posted-date">Posted on <span itemprop="datePublished" content="2023-04-24T08:00:00.000+08:00">2023‑04‑24</span></span></div><div class="d-flex flex-row align-items-center"><span class="post-updated-date-icon"><i class="fas fa-calendar post-meta-icon me-1"></i> </span><span class="fs-7 post-updated-date">Updated on <span itemprop="dateModified" content="2023-09-13T18:29:18.000+08:00">2023‑09‑13</span></span></div><div class="d-flex flex-row align-items-center"><span><i class="far fa-clock post-meta-icon me-1"></i> </span><span class="fs-7">8 minute read</span></div></div><div class="metadata-tag-container"><span><i class="fas fa-tag post-meta-icon me-1 mt-2"></i></span><div class="tag-list d-flex flex-row flex-wrap align-items-center"><span><a class="jtag" href="/tags/programming/" itemprop="keywords">programming</a> </span><span><a class="jtag" href="/tags/mathematics/" itemprop="keywords">mathematics</a> </span><span><a class="jtag" href="/tags/haskell/" itemprop="keywords">haskell</a> </span><span><a class="jtag" href="/tags/types/" itemprop="keywords">types</a> </span><span><a class="jtag" href="/tags/functional/" itemprop="keywords">functional</a> </span><span><a class="jtag" href="/tags/software-engineering/" itemprop="keywords">software-engineering</a> </span><span><a class="jtag" href="/tags/programming-languages/" itemprop="keywords">programming-languages</a></span></div></div></div></div><hr><div class="post-body text-content" itemprop="articleBody text"><p>Algebraic data types (ADTs) encompass a wide range of types commonly used in our day-to-day tasks. Over the past years, they’ve grown in popularity with the rise of modern languages such as Rust and Scala. They allow us to effectively model data, write readable code, and catch bugs at compile time. But rarely do we consider the aesthetics behind such constructs.</p><p>This post is for the curious programmer. Today, we’ll be looking at the mathematics behind ADTs. In doing so, we also gain an appreciation for their utility and aesthetics. I’ll be mainly using Haskell code blocks in this post, because types are very straightforward to express in this language. If you’re unfamiliar with Haskell, fear not!—the concepts addressed below are transferable to most programming languages.</p><h2 id="motivation-for-adts" tabindex="-1"><a class="md-anchor" href="#motivation-for-adts" aria-hidden="true"></a> Motivation for ADTs</h2><p>We are interested in combining types, but that alone isn’t saying much. First, we want to combine types <strong>meaningfully</strong> in order to communicate ideas through those types. This notion lies with expressibility and the art of programming. Code is, after all, a medium between programmers.</p><p>Second, we want to combine types <strong>concisely</strong>; our types shouldn’t contain redundant, ambiguous information. Removing redundancy implies removing duplicate or invalid states, leading to better maintainability and fewer bugs.</p><p>ADTs offers us two ways to combine types: <strong>product types</strong> and <strong>sum types</strong>.</p><h3 id="product-types" tabindex="-1"><a class="md-anchor" href="#product-types" aria-hidden="true"></a> Product Types</h3><p>If you’ve used structs, tuples, or record types, then you already have a sense of what product types are. Product types combine types together as one. A pizza is like a product type, combining crust, cheese, and toppings. When you bite into a pizza, you enjoy the sensation of all three together.</p><p>Here are some product types in Haskell:</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token comment">-- Haskell Tuple</span>
<span class="token comment">-- -------------</span>
<span class="token comment">-- Haskell separates types from data.</span>
<span class="token hvariable">tuple1</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token comment">-- Type</span>
<span class="token hvariable">tuple1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">)</span> <span class="token comment">-- Data</span>

<span class="token comment">-- Here's another tuple:</span>
<span class="token hvariable">tuple2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">tuple2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Hello world!"</span><span class="token punctuation">)</span>

<span class="token comment">-- We can have a product type of product types.</span>
<span class="token hvariable">tuple3</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Double</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">tuple3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">-- Although semantically, it's the same as...</span>
<span class="token hvariable">tuple4</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Double</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token hvariable">tuple4</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>

<span class="token comment">-- Haskell Data Constructor</span>
<span class="token comment">-- ------------------------</span>
<span class="token comment">-- We define a new type: RectangleType.</span>
<span class="token comment">-- We also define Rect to be a data constructor.</span>
<span class="token comment">-- The data constructor takes 4 integer arguments.</span>
<span class="token keyword">data</span> <span class="token constant">RectangleType</span> <span class="token operator">=</span> <span class="token constant">Rect</span> <span class="token constant">Int</span> <span class="token constant">Int</span> <span class="token constant">Int</span> <span class="token constant">Int</span>

<span class="token comment">-- We can create a RectangleType by passing concrete </span>
<span class="token comment">-- values to the Rect data constructor.</span>
<span class="token hvariable">rect</span> <span class="token operator">::</span> <span class="token constant">RectangleType</span>
<span class="token hvariable">rect</span> <span class="token operator">=</span> <span class="token constant">Rect</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span> <span class="token number">5</span>

<span class="token comment">-- Haskell Record</span>
<span class="token comment">-- --------------</span>
<span class="token comment">-- Let's define a record!</span>
<span class="token comment">-- With Haskell record syntax, we can give names to fields.</span>
<span class="token comment">-- Here, `Person` is both the type and data constructor.</span>
<span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">name</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span>

<span class="token comment">-- Let's construct a Person type! A person has a name AND an age.</span>
<span class="token hvariable">record</span> <span class="token operator">::</span> <span class="token constant">Person</span>
<span class="token hvariable">record</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">name</span><span class="token operator">=</span><span class="token string">"Peter Parker"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span><span class="token operator">=</span><span class="token number">16</span> <span class="token punctuation">}</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>In the final example above, we wrote a product type representing a <code>Person</code>. All people have <code>name</code> and <code>age</code> properties, so it makes sense to combine them in coexistence.</p><h3 id="sum-types" tabindex="-1"><a class="md-anchor" href="#sum-types" aria-hidden="true"></a> Sum Types</h3><p>Sum types are another way to combine types. In contrast to product types, sum types combine types <em>exclusively</em>. The choice of crust is like a sum type. Should the crust be thin, thick, or stuffed with cheese? We can only choose one option.</p><p><a class="lightbox-single" title="Sum types stand out from the historic dominance of product types." href="/img/posts/programming/concepts/mathematics-of-types/assets/sheesh-sum-types-500w.webp"><img class="mb-2 rw center jw-55" src="/img/posts/programming/concepts/mathematics-of-types/assets/sheesh-sum-types-500w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 500 / 559" alt="Teletubbies handstacking meme, sum types are different from product types." title="Sum types stand out from the historic dominance of product types." srcset="/img/posts/programming/concepts/mathematics-of-types/assets/sheesh-sum-types-256w.webp 256w, /img/posts/programming/concepts/mathematics-of-types/assets/sheesh-sum-types-500w.webp 500w" sizes="(max-width: 256px) 256px, 500px"></a></p><p>Sum types in their <em>simplest</em> form are just enums. In C/C++, we might define them like so:</p><div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
	False<span class="token punctuation">,</span>
	True<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">C++</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>In Haskell, a <code>Bool</code> can be defined like so:</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>Notice the vertical bar <code>|</code>. This means a value with type <code>Bool</code> can either be <code>False</code> or <code>True</code>. It can’t be both at the same time.</p><p>Sum types also allow us to represent more complex data structures. Suppose we want to model students and teachers in a school. The traditional object-oriented method would be to declare a base <code>Member</code> class, then derive <code>Student</code> and <code>Teacher</code> classes.</p><div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token comment">// C++ Object-Oriented Approach</span>
<span class="token keyword">using</span> Course <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span> <span class="token comment">// For simplicity, a course is simply a string.</span>

<span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Member</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// A student...</span>
    <span class="token keyword">int</span> year<span class="token punctuation">;</span>                    <span class="token comment">// ...belongs to a year.</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Course<span class="token operator">&gt;</span> courses<span class="token punctuation">;</span> <span class="token comment">// ...takes some courses.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Member</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Course<span class="token operator">&gt;</span> teaches<span class="token punctuation">;</span> <span class="token comment">// A teacher teaches some courses.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">C++</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>In functional programming, we could express a <code>Member</code> as a sum type of <code>Student</code> or <code>Teacher</code>.</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">type</span> <span class="token constant">Course</span> <span class="token operator">=</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">Member</span> <span class="token operator">=</span> <span class="token constant">Student</span> <span class="token punctuation">{</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token hvariable">courses</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Course</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
			<span class="token operator">|</span> <span class="token constant">Teacher</span> <span class="token punctuation">{</span> <span class="token hvariable">teaches</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Course</span><span class="token punctuation">]</span> <span class="token punctuation">}</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>Here, <code>Student</code> and <code>Teacher</code> are two branches of the <code>Member</code> type, and a <code>Member</code> can only be either a <code>Student</code> or a <code>Teacher</code>. We can also add more branches to the sum type, such as <code>Administrator</code>, <code>Visitor</code>, and so on.<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></p><p>There are pros and cons for choosing between the object-oriented approach and functional approach, but that’s a topic for another day.</p><p>Sum types also enable us to express errors in a type-safe way. We can create a <code>Maybe</code> type that can be either <code>Nothing</code> or <code>Just</code> with the former indicating no result, and the latter indicating some result. (More on this later!)</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>This type allows us to handle errors in a more structured way and avoid a lot of <code>if-else</code> statements (with the help of monads!).</p><p>To sum up, sum types enable us to express complex data structures, while avoiding redundancy and making our code more maintainable and type-safe.</p><div class="alert alert-info d-flex align-items-start"><i class="fas fa-bolt ms-1 me-3 mt-1 fs-4" role="img"></i><div class="alert-content flex-fill mt-0"><p>We call <code>Just</code> a <em>data constructor</em>. This means we can construct concrete data by applying values to <code>Just</code>, as if it were a function. For example, <code>Just 1</code>, <code>Just "in"</code>, and <code>Just (Just 42)</code> are all concrete data. The same applies to <code>False</code>, <code>True</code>, and <code>Nothing</code>, but those don’t take arguments.</p></div></div><h2 id="types-in-the-wild" tabindex="-1"><a class="md-anchor" href="#types-in-the-wild" aria-hidden="true"></a> Types in the Wild</h2><p>Let’s familiarise ourselves with ADTs and look at a few use cases.</p><p><a class="lightbox-single" title="std::any — I choose you!" href="/img/posts/programming/concepts/mathematics-of-types/assets/wild-types-510w.webp"><img class="mb-2 rw center jw-45" src="/img/posts/programming/concepts/mathematics-of-types/assets/wild-types-510w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 510 / 499" alt="Pokemon battle with the user pulling out their prized pokemon: std::any." title="std::any — I choose you!" srcset="/img/posts/programming/concepts/mathematics-of-types/assets/wild-types-256w.webp 256w, /img/posts/programming/concepts/mathematics-of-types/assets/wild-types-510w.webp 510w" sizes="(max-width: 256px) 256px, 510px"></a></p><h3 id="product-types-in-the-wild" tabindex="-1"><a class="md-anchor" href="#product-types-in-the-wild" aria-hidden="true"></a> Product Types in the Wild</h3><p>In most languages, product types are useful when passing/returning data containing multiple values. For instance, we can define a <code>divMod</code> function which returns the quotient and the remainder of two numbers.</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">divMod</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">`div`</span> <span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">`mod`</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">divMod</span> <span class="token number">5</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">divMod</span> <span class="token number">42</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><div class="alert alert-secondary d-flex align-items-start"><div class="alert-content flex-fill mt-0"><p>In the Haskell REPL, lines starting with <code>ghci&gt;</code> indicate REPL input. Other lines are REPL output.</p></div></div><h3 id="sum-types-in-the-wild" tabindex="-1"><a class="md-anchor" href="#sum-types-in-the-wild" aria-hidden="true"></a> Sum Types in the Wild</h3><p>There are two common sum types in the wild: <code>Maybe</code> (introduced previously) and <code>Either</code>. These are typically used to express errors: either an error occurred or a valid result is returned.</p><p><code>Maybe</code> and <code>Either</code> have other names as well. In Rust, they’re called <a href="https://doc.rust-lang.org/std/option/enum.Option.html" rel="noreferrer" target="_blank"><code>Option</code></a> and <a href="https://doc.rust-lang.org/std/result/enum.Result.html" rel="noreferrer" target="_blank"><code>Result</code></a>. In Scala, it’s <a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html" rel="noreferrer" target="_blank"><code>Option</code></a> (not the same one as Rust!) and <a href="https://www.scala-lang.org/api/2.13.6/scala/util/Either.html" rel="noreferrer" target="_blank"><code>Either</code></a>. In C++, it’s <a href="https://en.cppreference.com/w/cpp/utility/optional" rel="noreferrer" target="_blank"><code>optional</code></a> and <a href="https://github.com/TartanLlama/expected" rel="noreferrer" target="_blank"><code>expected</code></a><sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup>. This list isn't exhaustive, but it goes to show how ubiquitous sum types are—though not as widespread as product types, for historic reasons.</p><p>Again, <code>Maybe</code> is defined as a sum type like so:</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>Here, <code>a</code> is a type parameter, much like the type parameters in C++ templates and other generic programming languages. We can substitute types to get a <strong>concrete type</strong>. For example, we can have <code>Maybe Int</code>, <code>Maybe Bool</code>, <code>Maybe String</code>, or—for the absolute masochists—<code>Maybe (Maybe (Maybe Int))</code>!</p><p><code>Maybe</code> is commonly used to denote a computation that might fail. For instance, we can write a safe integer divide function which returns <code>Nothing</code> when the divisor is <code>0</code> (indicating an error, since we can't divide) and returning the wrapped quotient otherwise.</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">safeDiv</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token constant">Nothing</span> <span class="token keyword">else</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">`div`</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">safeDiv</span> <span class="token number">4</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token number">2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">safeDiv</span> <span class="token number">7</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">safeDiv</span> <span class="token number">7</span> <span class="token number">0</span>
<span class="token constant">Nothing</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p><code>Maybe</code> is used in other places where the error is obvious, such as in map lookup (where <code>Nothing</code> implies non-existence).</p><p><code>Either</code> is similar, but is defined over two type parameters.</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>The type parameters <code>a</code> and <code>b</code> can be anything; but commonly, <code>a</code> is used to describe an error (such as a <code>String</code> or an enum) while <code>b</code> is some successful computation.</p><p>In the wild, <code>Either</code> is used in Haskell parsing libraries to return parse results. Sometimes, the parse is successful and returns the generated tree or data (<code>Right</code>). Other times, the parse fails and the library returns information of where it failed (<code>Left</code>). For example, maybe it failed to parse an unexpected <code>:</code> at line 5, column 42 of something.json.</p><h2 id="the-algebra-of-types" tabindex="-1"><a class="md-anchor" href="#the-algebra-of-types" aria-hidden="true"></a> The Algebra of Types</h2><p>The astute may notice that product types combine types in an “<em><strong>and</strong></em>” fashion, whereas sum types do so in an “<em><strong>or</strong></em>” fashion. One of the alluring aspects of ADTs is that we can construct an algebra over them, allowing us to rigorously work with types.</p><p>In the following parts, we'll explore how types relate to math and apply algebraic principles similar to those from elementary!</p><div class="alert alert-info d-flex align-items-start"><i class="fas fa-circle-info ms-1 me-3 mt-1 fs-4" role="img"></i><div class="alert-content flex-fill mt-0"><p>A word on notation.</p><ul><li>Monospaced letters ($\texttt{a}$) denote types/code,</li><li>$|\texttt{a}|$ denotes the size of set <code>a</code>,</li><li>$\equiv$ denotes an isomorphism between types (as in $\texttt{Int} \equiv \texttt{Int}$), and</li><li>$=$ is reserved for good ol' algebraic equivalence.</li></ul></div></div><h3 id="types-as-sets" tabindex="-1"><a class="md-anchor" href="#types-as-sets" aria-hidden="true"></a> Types as Sets</h3><p>Let’s start by treating types as <em>sets of values</em>.<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> For instance, a <code>Bool</code> can be thought of as a set of two values: ${\texttt{True}, \texttt{False}}$, so $|\texttt{Bool}| = 2$.</p><p>What about a $(\texttt{Bool}, \texttt{Bool})$? Each <code>Bool</code> can be either <code>True</code> or <code>False</code>; thus their combination yields $|(\texttt{Bool}, \texttt{Bool})| = 2 \times 2 = 4$ values. Generalising this,</p><p>$$ |\texttt{(a, b)}| = |\texttt{a}| \times |\texttt{b}| $$</p><p>See how it got the name “product type”?</p><p>What about sum types? How many values can <code>Maybe Bool</code> take? In the <code>Nothing</code> branch, we have one value: <code>Nothing</code>. In the <code>Just</code> branch, we have two: <code>Just True</code> and <code>Just False</code>. Altogether, $|\texttt{Maybe Bool}| = 3$. In general,</p><p>$$ \begin{align*} |\texttt{Maybe a}| &amp;= |\texttt{a}| + 1 \\ |\texttt{Either a b}| &amp;= |\texttt{a}| + |\texttt{b}| \end{align*} $$</p><p>Indeed, product types resemble multiplication over spaces whereas sum types suggest addition over spaces.</p><h3 id="isomorphism-of-types" tabindex="-1"><a class="md-anchor" href="#isomorphism-of-types" aria-hidden="true"></a> Isomorphism of Types</h3><p>The above-mentioned mathematical representation may come in handy when refactoring/optimising code.</p><p>Suppose we want a type with two “bins”: bin A and bin B. Items can belong to either bin, but not both… How can we represent this as a type?</p><p>One way is to use <code>Either a a</code>. We let <code>Left x</code> denote items in bin A, and <code>Right x</code> denote those in bin B.</p><p>Is there another way to represent the problem? Yes: <code>(Bool, a)</code>. We can use the <code>Bool</code> to flag whether the corresponding item is in bin A. Thus, <code>(True, x)</code> and <code>(False, x)</code> are used to denote items in bin A and B respectively.</p><p>In fact, we’ve just constructed an <strong>isomorphism</strong> between types!</p><p>The beauty is in the algebra. The equivalence above can be succinctly (and abstractly!) written as $\texttt{Either a a} {} \equiv \texttt{(Bool, a)}$—or more algebraically, $a + a = 2a$.</p><div class="alert alert-info d-flex align-items-start"><i class="fas fa-bolt ms-1 me-3 mt-1 fs-4" role="img"></i><div class="alert-content flex-fill mt-0"><p>More formally, an isomorphism exists between types <code>a</code> and <code>b</code> if we can <em>convert between the two types without loss of information</em>. The most straightforward approach is to define two functions: <code>toRHS :: a -&gt; b</code> and <code>toLHS :: b -&gt; a</code>. Alternatively with the algebra presented above, we can easily prove isomorphisms by checking the algebraic equivalence of two types!</p></div></div><p>With the toy example presented above, our converters would be</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token hvariable">toRHS</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">toRHS</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token hvariable">toRHS</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

<span class="token hvariable">toLHS</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span>
<span class="token hvariable">toLHS</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">x</span>
<span class="token hvariable">toLHS</span> <span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token hvariable">x</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>Notice how information is preserved, i.e. $\texttt{toLHS }(\texttt{toRHS } x) = x,\ \forall x \in \texttt{Either a a}$ and $\texttt{toRHS } (\texttt{toLHS }y) = y, \ \forall y \in \texttt{(Bool, a)}$.</p><p>In the same vein, the following types are also equivalent:</p><p>$$\texttt{Maybe (Maybe a)} \equiv \texttt{Either Bool a}$$</p><p>$$\texttt{Maybe} \texttt{(Either (a, a) (Bool, a))} \equiv \texttt{(Maybe a, Maybe a)}$$</p><h3 id="unit-values-in-the-algebra-of-types" tabindex="-1"><a class="md-anchor" href="#unit-values-in-the-algebra-of-types" aria-hidden="true"></a> Unit Values in the Algebra of Types</h3><p>But wait, there’s more! There are also <em>null</em> and <em>unit</em> types which behave just like 0 and 1 in the integers, with the usual axioms.</p><p>Meet <code>Void</code> and <code>()</code>, two very special types. <code>Void</code> resembles the null set: it has <em>no concrete values</em>. So how is this type used? Well, without any concrete values, its primary utility is in the type level. For example, in the <a href="https://hackage.haskell.org/package/megaparsec" rel="noreferrer" target="_blank">Megaparsec</a> parsing library, <code>Void</code> is used in <code>Parsec Void u a</code> to indicate a default option.</p><p><code>()</code> is the 0-tuple, the singleton set containing <code>()</code> itself. (To clarify, “<code>()</code>” is both a type and a value, depending on the context.)</p><div class="alert alert-warning d-flex align-items-start"><i class="fas fa-triangle-exclamation ms-1 me-3 mt-1 fs-4" role="img"></i><div class="alert-content flex-fill mt-0"><p>C’s <code>void</code> should <strong>not</strong> be confused with Haskell’s <code>Void</code>. The former is more like <code>()</code>, containing only one possible result.</p></div></div><p>With these funky creatures, we can write isomorphisms such as:</p><ul><li><p>$\texttt{Either Void a} \equiv \texttt{a}$</p><ul><li>Corresponds to $0 + a = a$.</li><li>Bijection:<div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token hvariable">toRHS</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">Void</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">toRHS</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token comment">-- toRHS (Left x) = undefined -- Implicit.</span>

<span class="token hvariable">toLHS</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token constant">Void</span> <span class="token hvariable">a</span>
<span class="token hvariable">toLHS</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token hvariable">x</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div></li></ul></li><li><p>$\texttt{((), a)} \equiv \texttt{a}$</p><ul><li>Corresponds to $1 \times a = a$.</li><li>Bijection:<div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token hvariable">toRHS</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">toRHS</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">toLHS</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">toLHS</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div></li></ul></li></ul><p>You may verify that the bijections<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> hold, i.e. show that $\texttt{toLHS }(\texttt{toRHS } x) = x$ and $\texttt{toRHS }(\texttt{toLHS } y) = y$ for any $x$ and $y$.</p><p>As for other algebraic constructions, I shall kindly leave them as an exercise for the reader. 🙃 Try coming up with examples of types and bijections for the following:</p><ul><li>Associativity: $(a + b) + c = a + (b + c)$, $(ab)c = a(bc)$</li><li>Commutativity: $a + b = b + a$, $ab = ba$</li><li>Distribution: $a(b + c) = ab + ac$</li><li>Null: $0a = 0$</li></ul><h3 id="enums-as-sum-types" tabindex="-1"><a class="md-anchor" href="#enums-as-sum-types" aria-hidden="true"></a> Enums as Sum Types</h3><p>An aside regarding sum types and enums.</p><p>Early on I mentioned sum types as <a href="#motivation-for-adts">a way to combine <em>types</em></a>. Then I suggested <a href="#sum-types"><em>enums</em> as an example of sum types</a>… But we usually think of enums as combining <em>values</em>, not <em>types</em>. What’s going on here?</p><p>Well, one way to view enums is to treat each value as if they take a unit type <code>()</code> parameter. That is,</p><div class="code-toolbar"><pre class="language-haskell" tabindex="0"><code class="language-haskell"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">True</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><div class="toolbar"><div class="toolbar-item"><span class="lang">Haskell</span></div><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" title="Copy Code"></button></div></div></div><p>(N.B. $\texttt{Bool} \equiv \texttt{Either () ()}$.)</p><p>Here, <code>False</code> is a <em>data constructor</em> while <code>()</code> is a <em>type</em>. In this version of <code>Bool</code>, we’re basically combining a bunch of unit types <code>()</code> using different tags.</p><p>In this regard, we can think of enums as sugar-coated sum types; and conversely, sum types can be thought of as glorified enums. We’ve seen how enums and sum types can be defined similarly in Haskell. The same goes for Rust and Scala 3, where the <code>enum</code> keyword is not only used to define enums, but also sum types (and in general, ADTs).</p><h2 id="conclusion-and-recap" tabindex="-1"><a class="md-anchor" href="#conclusion-and-recap" aria-hidden="true"></a> Conclusion and Recap</h2><p>Is that all?</p><p>Au contraire.</p><p>Algebraic data types may be sufficient for most use cases, but we’ve only scratched the surface. There are more quirky animals out there! Generalised ADTs. Union/disjunctive types. Conjunctive/intersection types. Pi types.</p><p>But to recap:</p><ul><li><strong>Algebraic data types (ADTs)</strong> consist of <em>product types</em> and <em>sum types</em>.</li><li>By leveraging ADTs, we can write code that is meaningful and concise, modelling the real world more closely.</li><li>There are two main forms of ADTs. Both enable us to combine smaller types into larger types.<ul><li><strong>Product types</strong> can be thought of as a <em>multiplication on types</em>.</li><li>Similarly, <strong>sum types</strong> are like a <em>summation on types</em>.</li></ul></li><li>ADTs follow mathematical laws similar to other structures (e.g. the integers), but without the inverse property. These mathematical laws allow us to rigorously reason with types.<ul><li>We can express ADTs through a mathematical algebra such as $|\texttt{(a, b)}| = a \times b$ and $|\texttt{Either a b}| = a + b$.</li><li>Types with an equivalent algebraic representation are <strong>isomorphic</strong>. This may prove useful in refactoring and optimising.</li><li>The algebra of types follows <strong>algebraic laws</strong> similar to the laws for integers and other algebras. There are laws on identity (e.g. $0 + a = a$), associativity, distribution, etc.</li></ul></li><li>Thus, in addition to their utilitarian use, types also exhibit an aesthetic beauty.</li></ul><h3 id="references-further-reading" tabindex="-1"><a class="md-anchor" href="#references-further-reading" aria-hidden="true"></a> References/Further Reading</h3><ul><li><a href="https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945" rel="noreferrer" target="_blank">The Algebra of Algebraic Data Types: Part 1</a> by Chris Taylor</li><li><a href="https://kseo.github.io/posts/2016-12-25-type-isomorphism.html" rel="noreferrer" target="_blank">Type Isomorphism</a> by Kwang Yul Seo</li><li><a href="https://web.archive.org/web/20140122164049/http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/" rel="noreferrer" target="_blank">The Algebra of Algebraic Data Types: Part 2</a> by Chris Taylor (dives into recursive ADTs!)</li></ul><hr class="footnotes-sep"><b>Footnotes</b><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>We could do the same in C++ by using <a href="https://theboostcpplibraries.com/boost.variant" rel="noreferrer" target="_blank">Boost variant</a>, using <a href="https://en.cppreference.com/w/cpp/utility/variant" rel="noreferrer" target="_blank">C++17’s <code>std::variant</code></a>, or using a tagged union (which is just a <code>union</code> with a <code>uint8_t</code>/<code>int</code> tag). <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><code>std::optional</code> was introduced in C++17, and <code>std::expected</code> is expected (haha) to arrive with C++23. You can still pull these types from various libraries though. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>I should mention—there are significant differences between types and sets. But please bear with me, for the sake of this post. ._. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>A <a href="https://en.wikipedia.org/wiki/Bijection" rel="noreferrer" target="_blank">bijection</a> is also known as a <em>one-to-one correspondence</em> or <em>invertible</em> function. Each input must map to one (and only one) unique output.<br>Functions such as $x \mapsto \sqrt{x}$ and $x \mapsto \lfloor x \rfloor$ are not bijections since multiple inputs may map to the same output—we can't recover a unique input given an output. This is the whole idea of being <em>invertible</em>. <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section></div><a id="end-of-article"></a><br><script defer src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><div class="post-share dim-gentle mb-3 d-flex flex-row align-items-center"><div class="d-flex flex-row flex-wrap align-items-center gap-3"><span>Share&nbsp;on</span> <a class="no-decoration" data-sharer="reddit" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-reddit"></i> </span></a><a class="no-decoration" data-sharer="telegram" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-telegram"></i> </span></a><a class="no-decoration" data-sharer="whatsapp" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-whatsapp"></i> </span></a><a class="no-decoration" data-sharer="linkedin" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-linkedin"></i> </span></a><a class="no-decoration" data-sharer="vk" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-vk"></i> </span></a><a class="no-decoration" data-sharer="twitter" data-title="The Mathematics of Types" data-url="https://trebledj.me/posts/the-mathematics-of-types/"><span class="fs-4"><i class="fab fa-twitter"></i> </span></a><a id="copy-link-button" class="no-decoration" data-bs-toggle="tooltip" data-bs-trigger="click" title="Link copied!"><span class="fs-4"><i class="fas fa-link"></i></span></a></div></div><hr><div id="post-author-container" class="d-flex justify-content-between align-items-center gap-3" itemprop="author" itemscope itemtype="https://schema.org/Person"><img src="/img/profile-icon.jpg" class="profile-img" alt="" loading="lazy" decoding="async" itemprop="image"><div class="author-info d-flex flex-column gap-1"><p class="profile-name" itemprop="name">TrebledJ</p><p class="profile-bio" itemprop="description">Passionate problem-solver, pentester, and autodidact. I thrive on learning new things and enjoy passing it on. When not immersed in bughunting or programming, I can be found taking walks, composing a short tune, and occasionally indulging in CTF challenges.</p></div></div><hr class="section-sep"><div id="related" class="jw-100"><h3><i class="fas fa-circle-nodes me-2"></i>Related Posts</h3><div class="row gx-3 mt-4"><div class="related-col-flex-auto-4"><article class="post-minified-preview"><a href="/posts/implicit-parameters-in-scala-and-haskell/"></a><div class="d-flex flex-column"><a class="post-thumbnail" href="/posts/implicit-parameters-in-scala-and-haskell/"><img class="post-img-blurred-bg" src="/img/posts/programming/concepts/implicit-parameters/assets/thumbnail-512w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 512 / 288" alt="Thumbnail for Implicit Parameters in Scala and Haskell" srcset="/img/posts/programming/concepts/implicit-parameters/assets/thumbnail-256w.webp 256w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-512w.webp 512w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-1024w.webp 1024w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-1060w.webp 1060w" sizes="(max-width: 256px) 256px, (max-width: 512px) 512px, 512px"><div class="post-img-container d-flex jw-100 h-100"><img class="post-img-contain" src="/img/posts/programming/concepts/implicit-parameters/assets/thumbnail-512w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 512 / 288" alt="Thumbnail for Implicit Parameters in Scala and Haskell" srcset="/img/posts/programming/concepts/implicit-parameters/assets/thumbnail-256w.webp 256w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-512w.webp 512w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-1024w.webp 1024w, /img/posts/programming/concepts/implicit-parameters/assets/thumbnail-1060w.webp 1060w" sizes="(max-width: 256px) 256px, (max-width: 512px) 512px, 512px"></div></a><div class="post-content d-flex flex-column justify-content-between"><div><h2 class="post-title">Implicit Parameters in Scala and Haskell</h2><div class="post-summary"><p>...and also C++ (kinda).</p></div></div><div class="metadata-tag-container d-flex flex-row align-items-top"><div class="tag-list mt-2 d-flex flex-row flex-wrap align-items-center"><span><a class="jtag" href="/tags/programming/" itemprop="keywords">programming</a> </span><span><a class="jtag" href="/tags/tutorial/" itemprop="keywords">tutorial</a> </span><span><a class="jtag" href="/tags/programming-languages/" itemprop="keywords">programming-languages</a></span></div></div></div></div></article></div><div class="related-col-flex-auto-4"><article class="post-minified-preview"><a href="/posts/aoc-2021-haskell-utils/"></a><div class="d-flex flex-column"><a class="post-thumbnail" href="/posts/aoc-2021-haskell-utils/"><img class="post-img-blurred-bg" src="/img/posts/programming/aoc-2021/assets/recycle-hs-utils-512w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 512 / 331" alt="Thumbnail for AOC 2021 Haskell Utils" srcset="/img/posts/programming/aoc-2021/assets/recycle-hs-utils-256w.webp 256w, /img/posts/programming/aoc-2021/assets/recycle-hs-utils-512w.webp 512w, /img/posts/programming/aoc-2021/assets/recycle-hs-utils-771w.webp 771w" sizes="(max-width: 256px) 256px, (max-width: 512px) 512px, 512px"><div class="post-img-container d-flex jw-100 h-100"><img class="post-img-contain" src="/img/posts/programming/aoc-2021/assets/recycle-hs-utils-512w.webp" loading="lazy" decoding="async" style="aspect-ratio: auto 512 / 331" alt="Thumbnail for AOC 2021 Haskell Utils" srcset="/img/posts/programming/aoc-2021/assets/recycle-hs-utils-256w.webp 256w, /img/posts/programming/aoc-2021/assets/recycle-hs-utils-512w.webp 512w, /img/posts/programming/aoc-2021/assets/recycle-hs-utils-771w.webp 771w" sizes="(max-width: 256px) 256px, (max-width: 512px) 512px, 512px"></div></a><div class="post-content d-flex flex-column justify-content-between"><div><h2 class="post-title">AOC 2021 Haskell Utils</h2><div class="post-summary"><p>An introduction and walkthrough of my haskell utilities.</p></div></div><div class="metadata-tag-container d-flex flex-row align-items-top"><div class="tag-list mt-2 d-flex flex-row flex-wrap align-items-center"><span><a class="jtag" href="/tags/programming/" itemprop="keywords">programming</a> </span><span><a class="jtag" href="/tags/aoc/" itemprop="keywords">aoc</a> </span><span><a class="jtag" href="/tags/haskell/" itemprop="keywords">haskell</a></span></div></div></div></div></article></div></div><hr><h3><i class="fas fa-tags me-2"></i>Related Tags</h3><div class="mt-3"><h4><abbr data-bs-placement="top" data-bs-toggle="tooltip" title="Related to functional, programming, programming-languages, software-engineering, types">software.general</abbr></h4><span class="d-flex flex-wrap"><a class="jtag" href="/tags/programming/">programming</a> <a class="jtag" href="/tags/software-engineering/">software-engineering</a> <a class="jtag" href="/tags/web/">web</a> <a class="jtag" href="/tags/aoc/">aoc</a> <a class="jtag" href="/tags/apps/">apps</a> <a class="jtag" href="/tags/dsp/">dsp</a> <a class="jtag" href="/tags/programming-languages/">programming-languages</a> <a class="jtag" href="/tags/linux/">linux</a> <a class="jtag" href="/tags/performance/">performance</a> <a class="jtag" href="/tags/functional/">functional</a> <a class="jtag" href="/tags/types/">types</a> <a class="jtag" href="/tags/windows/">windows</a> <a class="jtag" href="/tags/ai/">ai</a> <a class="jtag" href="/tags/metaprogramming/">metaprogramming</a> <a class="jtag" href="/tags/oop/">oop</a></span></div><div class="mt-3"><h4><abbr data-bs-placement="top" data-bs-toggle="tooltip" title="Related to haskell">software.programming-language</abbr></h4><span class="d-flex flex-wrap"><a class="jtag" href="/tags/cpp/">cpp</a> <a class="jtag" href="/tags/python/">python</a> <a class="jtag" href="/tags/c/">c</a> <a class="jtag" href="/tags/haskell/">haskell</a> <a class="jtag" href="/tags/js/">js</a> <a class="jtag" href="/tags/qt/">qt</a> <a class="jtag" href="/tags/rust/">rust</a> <a class="jtag" href="/tags/qml/">qml</a> <a class="jtag" href="/tags/sql/">sql</a> <a class="jtag" href="/tags/java/">java</a> <a class="jtag" href="/tags/scala/">scala</a></span></div><div class="mt-3"><h4><abbr data-bs-placement="top" data-bs-toggle="tooltip" title="Related to mathematics">misc</abbr></h4><span class="d-flex flex-wrap"><a class="jtag" href="/tags/writeup/">writeup</a> <a class="jtag" href="/tags/notes/">notes</a> <a class="jtag" href="/tags/tutorial/">tutorial</a> <a class="jtag" href="/tags/project/">project</a> <a class="jtag" href="/tags/reflection/">reflection</a> <a class="jtag" href="/tags/hkust/">hkust</a> <a class="jtag" href="/tags/experience/">experience</a> <a class="jtag" href="/tags/research/">research</a> <a class="jtag" href="/tags/faith/">faith</a> <a class="jtag" href="/tags/learning/">learning</a> <a class="jtag" href="/tags/meta/">meta</a> <a class="jtag" href="/tags/mathematics/">mathematics</a> <a class="jtag" href="/tags/cheatsheet/">cheatsheet</a> <a class="jtag" href="/tags/satire/">satire</a> <a class="jtag" href="/tags/essay/">essay</a> <a class="jtag" href="/tags/reading/">reading</a></span></div></div><hr class="section-sep"><div class="container-md mt-4 p-4"><a id="comments"></a><p>Comments are back! Privacy-focused; without ads, bloatware 🤮, and trackers. Be one of the first to contribute to the discussion— before AI invades social media, world leaders declare war on guppies, and what little humanity left is lost to time.</p><script defer src="/js/comentario.min.js"></script><script>if(window.location.hash.startsWith("#comentario")){const a=document.getElementById("comments");a&&a.scrollIntoView({behavior:"smooth"})}</script><comentario-comments id="comentario" auto-init="false" no-fonts="true" css-override="false" theme="dark"></comentario-comments></div><br></div></div></article></div></div></div><footer class="d-flex flex-column gap-2"><div class="d-flex flex-row gap-3 mx-auto" style="width:fit-content;"><a rel="me noreferrer" href="https://github.com/TrebledJ" target="_blank"><i class="social-icon fab fa-github" style="color:rgb(150, 60, 180) !important;"></i> </a><a rel="me noreferrer" href="https://infosec.exchange/@trebledj" target="_blank"><i class="social-icon fab fa-mastodon" style="color:rgb(99, 101, 255) !important;"></i> </a><a rel="me noreferrer" href="https://x.com/trebledjjj" target="_blank"><i class="social-icon fab fa-twitter" style="color:rgb(99, 101, 255) !important;"></i> </a><a rel="me noreferrer" href="https://stackoverflow.com/users/10239789/trebledj" target="_blank"><i class="social-icon fab fa-stack-overflow" style="color:rgb(236, 124, 34) !important;"></i> </a><a rel="me noreferrer" href="https://soundcloud.com/trebledj" target="_blank"><i class="social-icon fab fa-soundcloud" style="color:rgb(237, 110, 30) !important;"></i> </a><a rel="me noreferrer" href="https://discordapp.com/users/220427982798454794" target="_blank"><i class="social-icon fab fa-discord" style="color:rgb(84, 100, 235) !important;"></i> </a><a rel="me" href="mailto:trebledjjj@gmail.com"><i class="social-icon fas fa-envelope"></i> </a><a rel="me" href="/feeds"><i class="social-icon fas fa-square-rss"></i></a></div><p>Copyright&nbsp;©&nbsp;2026&nbsp;TrebledJ • <a href="/privacy-policy">Privacy&nbsp;Policy</a> • <a href="https://github.com/TrebledJ/trebledj.github.io?tab=readme-ov-file#credits--appreciation" rel="noreferrer" target="_blank">Credits</a></p></footer><script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js"></script><script>var tocOptions={}</script><script defer src="/cb/YmP0cUsv-I.js"></script><link href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" rel="stylesheet" media="print"><script>document.querySelectorAll('link[media|="print"]').forEach(e=>{e.addEventListener("load",()=>e.media="all"),e.sheet&&(e.media="all")})</script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!0})})</script><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;52d99b3d385b4c9a98ac8ad109a95a2a&quot;}"></script></body></html>